#' Convert beta values from Bisulphite Sequencing to single CpG island beta values
#'
#' Reduce beta values from different CpG sites to single beta values
#' associated to one CpG island where CpG sites are located.
#'
#' Bisulphite Sequencing is used to retrieve level of DNA methylation at
#' base resolution. Different experiments may retrieve
#' different CpG sites. This function makes a direct comparison possible.
#'
#' @param cpg_sites_matrix A matrix of beta values.
#' @param cpg_indexes A list of indexes generated by
#' \code{compute_islands_indexes}.
#' @param min_CpGs An integer (default to 3). Minimum number of CpG sites
#' within a single CpG island required to compute the reduced beta value
#' (return NA otherwise).
#' @param ncores Number of parallel processes to use for parallel computing
#' @return A matrix of beta values (nrow == length(cpg_indexes)).
#' @importFrom stats median
#' @export
#' @examples
#' reduced_tumor <- reduce_to_islands(bs_toy_matrix[,1:10], bs_toy_indexes)
#' reduced_control <- reduce_to_islands(bs_toy_matrix[,11:20], bs_toy_indexes)
reduce_to_islands <- function(cpg_sites_matrix, cpg_indexes, min_CpGs = 3,
  ncores=1){
  # check parameters
  cpg_sites_matrix <- as.matrix(cpg_sites_matrix)
  diff_range <- diff(range(cpg_sites_matrix, na.rm = TRUE))
  # assertthat::assert_that(diff_range > 1 && diff_range <= 100,
  #   msg=paste("For computation efficiency, convert cpg island table",
  #       "to percentage values (range: 0-100)."))
  # cpg_sites_matrix <- round(cpg_sites_matrix)
  # storage.mode(cpg_sites_matrix) <- "integer"

  assertthat::assert_that(is.list(cpg_indexes))

  system_cores <- parallel::detectCores()
  assertthat::assert_that(ncores < system_cores)

  message(sprintf("[%s] Reducing beta values...",  Sys.time()))
  cpg_islands_data <- parallel::mclapply(mc.cores=ncores, cpg_indexes,
    function(idx) median_island(cpg_sites_matrix[idx, , drop = FALSE], min_CpGs))
  cpg_islands_data <- do.call("rbind", cpg_islands_data)

  if (is.null(names(cpg_indexes))) {
    names(cpg_indexes) <- paste0("cpg", seq(1, length(cpg_indexes)))
  }
  rownames(cpg_islands_data) <- names(cpg_indexes)
  message(sprintf("[%s] Done",  Sys.time()))
  return(cpg_islands_data)
}

#' Convert CpG sites to one CpG island
#'
#' If the number of sites is sufficient take the median value else
#' return NA.
#' @param x A matrix.
#' @param n Minimum required number of sites per island (return NA otherwise)
#' @keywords internal
median_island <- function(x, n) {
  if (nrow(x) < n) {
    beta_values <- NA
  } else {
    # identify sites without beta-score
    all_NAs_sites <- rowSums(is.na(x)) == ncol(x)
    if (sum(!all_NAs_sites) < n) {
      beta_values <- NA
    } else {
      beta_values <- apply(x, 2, median, na.rm = TRUE)
    }
  }
  return(beta_values)
}
