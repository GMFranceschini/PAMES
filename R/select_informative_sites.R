#' Select informative CpG sites
#'
#' This function generates a list of informative CpG sites to be used to estimate
#' the purity of a set of tumor samples.
#'
#' Informative sites are divided into \code{hyper} and \code{hypo} depending on
#' their level of methylation with respect to the average beta-score of normal
#' samples. Both sets will be used to compute purity.
#'
#' @param tumor_table A matrix of beta-values (percentage) from tumor samples.
#' @param auc A vector of AUC scores generated by \code{compute_AUC}.
#' @param max_sites Maximum number of sites to retrieve (half hyper-, half
#' hypo-methylated) (default = 20).
#' @param min_distance To avoid selection of CpG sites located within such
#' distance from one another (default = 1e6 bps).
#' @param hyper_range A vector of length 2 with minimum lower and upper values
#' required to select hyper-methylated informative sites.
#' @param hypo_range A vector of length 2 with minimum lower and upper values
#' required to select hypo-methylated informative sites.
#' @param platform Illumina platform used in the experiment (\strong{450k} or
#' \strong{27k}).
#' @param genome Genome version: used to exclude probes located too close to
#' each other (\strong{hg19} or \strong{hg38}).
#' @return A named list of indexes of informative sites ("hyper-" and "hypo-methylated").
#' @export
#' @examples
#' ## WARNING: The following code doesn't retrieve any informative site
#' ## Its only purpose is to show how to use the tool
#' auc_data <- compute_AUC(tumor_toy_data, control_toy_data)
#' info_sites <- select_informative_sites(tumor_toy_data, auc_data, platform="27k")
#' info_sites.hg38 <- select_informative_sites(tumor_toy_data, auc_data, platform="27k", genome="hg38")
select_informative_sites <- function(tumor_table, auc, max_sites = 20, min_distance = 1e6,
  hyper_range = c(min = 40, max = 90), hypo_range = c(min = 10, max = 60),
  genome = c("hg19", "hg38"), platform = c("450k", "27k")){

  message(sprintf("[%s] # Select informative sites #", Sys.time()))
  # check parameters
  platform <- match.arg(platform)
  genome <- match.arg(genome)
  platform_data <- get(paste0("illumina", platform, "_", genome))

  diff_range_t <- diff(range(tumor_table, na.rm = TRUE))
  assertthat::assert_that(diff_range_t > 1, diff_range_t <= 100,
    msg="For computation efficiency convert tumor table to percentage values.")
  tumor_table <- as.matrix(tumor_table)
  tumor_table <- round(tumor_table)
  storage.mode(tumor_table) <- "integer"

  assertthat::assert_that(nrow(tumor_table) == length(auc))
  assertthat::assert_that(nrow(tumor_table) == nrow(platform_data),
    msg=paste("Number of rows of tumor_table is not equal to the number of rows of platform_data.",
      "Be sure to use correct platform and genome version and to remove any non-'cg' probe from tumor_table."))

  max_sites <- as.integer(max_sites)
  assertthat::assert_that(max_sites %% 2 == 0, msg="max_sites is not even")

  min_distance <- as.integer(min_distance)
  assertthat::assert_that(min_distance > 0)

  hyper_range <- as.numeric(hyper_range)
  hypo_range <- as.numeric(hypo_range)
  assertthat::assert_that(length(hyper_range) == 2)
  assertthat::assert_that(length(hypo_range) == 2)

  message(sprintf("Selected genome: %s", genome))
  message(sprintf("Selected platform: %s", platform))
  message(sprintf("Selected number of sites to retrieve: %i", max_sites))
  message(sprintf("Selected miniminum distance between sites: %g bps", min_distance))
  message(sprintf("Selected hyper-methylated sites range: %i-%i", hyper_range[1], hyper_range[2]))
  message(sprintf("Selected hyper-methylated sites range: %i-%i", hypo_range[1], hypo_range[2]))

  # minimum and maximum beta per site ----------------------------------------
  beta_high <- suppressWarnings(apply(tumor_table, 1, max, na.rm = TRUE))
  beta_low  <- suppressWarnings(apply(tumor_table, 1, min, na.rm = TRUE))
  hyper_idx <- which(beta_low < hyper_range[1] & beta_high > hyper_range[2] & auc > .80)
  hypo_idx  <- which(beta_low < hypo_range[1]  & beta_high > hypo_range[2]  & auc < .20)

  message(sprintf("[%s] Total hyper-methylated sites retrieved = %i", Sys.time(), length(hyper_idx)))
  message(sprintf("[%s] Total hypo-methylated sites retrieved = %i",  Sys.time(), length(hypo_idx)))

  ordered_hyper_idx <- hyper_idx[order(auc[hyper_idx], decreasing = TRUE)]
  ordered_hypo_idx  <- hypo_idx[order(auc[hypo_idx],   decreasing = FALSE)]

  message(sprintf("[%s] Reducing hyper-methylated clusters...", Sys.time()))
  top_hyper_idx <- cluster_reduction(ordered_hyper_idx, max_sites/2, min_distance, platform_data)
  message(sprintf("[%s] Retrieved hyper-methylated sites = %i", Sys.time(), length(top_hyper_idx)))

  message(sprintf("[%s] Reducing hypo-methylated clusters...", Sys.time()))
  top_hypo_idx <- cluster_reduction(ordered_hypo_idx, max_sites/2, min_distance, platform_data)
  message(sprintf("[%s] Retrieved hypo-methylated sites = %i", Sys.time(), length(top_hypo_idx)))

  message(sprintf("[%s] Done", Sys.time()))
  return(list(hyper = top_hyper_idx, hypo = top_hypo_idx))
}

#' Remove CpG sites too close to each other
#'
#' Takes a vector of indexes (ordered by AUC) and
#' removes sites within 'min_distance' (keep one per 'cluster'), keeping
#' at most N sites accoring to their order.
#' @param sites_idx a vector of integers
#' @param N number of sites to retrieve
#' @param min_distance an integer (in basepairs)
#' @param platform_data a data.frame with info about probes location
#' (either \strong{450k} or \strong{27k}).
#' @keywords internal
#' @return a vector of indexes with close sites removed.
cluster_reduction <- function(sites_idx, N, min_distance, platform_data){
  # allocate space for possible sites
  top_idx <- rep(NA, length(sites_idx))
  i <- 1
  n <- 1
  while (n <= N & i <= length(sites_idx)) {
    idx <- sites_idx[i]
    if (!is_too_close(idx, top_idx[!is.na(top_idx)], min_distance, platform_data)) {
      top_idx[n] <- idx
      n <- n + 1
    }
    i <- i + 1
  }
  # remove NA leftovers
  return(top_idx[!is.na(top_idx)])
}

#' Check whether a site is too close to the other sites or not
#'
#' Used in "cluster_redution" function only, given the index of a CpG site and
#' a set of indexes of other sites, check if last added site is less than
#' "min_distance" basepair distant from previously retrieved sites.
#' @param new_idx an index (integer)
#' @param prev_idxs a vector of indexes (integer)
#' @param min_distance an integer. Distance in basepairs
#' @param platform_data a data.frame with info about probes location
#' (either \strong{450k} or \strong{27k}).
#' @keywords internal
#' @return logical
is_too_close <- function(new_idx, prev_idxs, min_distance, platform_data){
  if (length(prev_idxs) == 0) {
    answer <- FALSE
  } else {
    new_site <- platform_data[new_idx,]
    other_sites <- platform_data[prev_idxs,]
    same_chromosome <- other_sites[["Chromosome"]] == new_site[["Chromosome"]]
    if ("Start" %in% names(platform_data)){
      within_min_distance <-
        abs(other_sites[["Start"]] - new_site[["Start"]]) < min_distance
    } else {
      within_min_distance <-
        abs(other_sites[["Genomic_Coordinate"]] - new_site[["Genomic_Coordinate"]]) < min_distance
    }
    # pairwise comparision of chromosome location and distance
    answer <- any(same_chromosome & within_min_distance)
  }
  return(ifelse(test = is.na(answer), yes = FALSE, no = answer))
}

