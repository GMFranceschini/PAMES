#' Select informative CpG sites
#'
#' Generate a list of informative CpG sites to be used to compute purity of
#' a set of tumor samples.
#'
#' Informative sites are divided into \code{hyper} and \code{hypo} depending
#' on their level of
#' methylation with respect to the average beta value of normal samples.
#' Both sets will be used to compute purity.
#'
#' @param tumor a matrix of beta scores generated by an Illumina BeadChip.
#' @param control a matrix of beta scores generated by an Illumina BeadChip.
#' @param max_sites maximum number of sites to retrieve (half "hyper-", half "hypo-methylated") (default=20).
#' @param min_distance measured in bp (base pair), used to avoid selection
#' of CpG sites located within this distance from one another (default=1e6).
#' @param platform \strong{27k} or \strong{450k} Illumina BeadChip.
#' @param genome \strong{hg19} or \strong{hg38}. Used to map probes to genome and
#' remove heavily clustered probes.
#' @return a list of indexes of informative sites (divided into two sets:
#' "hyper-" and "hypo-methylated").
#' @export
#' @examples
#' \donttest{
#' info_sites <- select_informative_sites(tumor_toy_data,
#'                                        control_toy_data,
#'                                        auc_data,
#'                                        platform="27k")
#' info_sites.hg38 <- select_informative_sites(tumor_toy_data,
#'                                             control_toy_data,
#'                                             auc_data,
#'                                             platform="27k",
#'                                             genome="hg38")
#' }

select_informative_sites <- function(tumor,
                                     control,
                                     auc,
                                     max_sites=20,
                                     min_distance=1e6,
                                     genome=c("hg19", "hg38"),
                                     platform=c("450k", "27k")){
    # check parameters ---------------------------------------------------------
    platform <- match.arg(platform)
    genome <- match.arg(genome)
    message(sprintf("Genome: %s", genome))
    message(sprintf("Platform: %s", platform))

    platform_data <- get(paste0("illumina", platform, "_", genome))

    min_distance <- as.integer(min_distance)
    if (min_distance < 0)
       stop("'min_distance' must be positive")
    if (max_sites %% 2 != 0 & !is.integer(max_sites))
        stop ("'max_sites' must be an integer and even number")

    tumor   <- as.matrix(tumor)
    control <- as.matrix(control)

    if (any(tumor < 0 | tumor > 1, na.rm=T) | any(control < 0 | control > 1, na.rm=T))
        stop("Beta values in 'tumor' and 'control' matrixes must be decimal.")

    if (nrow(tumor) != nrow(platform_data) | nrow(control) != nrow(platform_data))
        stop(paste0(sprintf("'tumor' and 'control' must have %i number of rows.\n", nrow(platform_data)),
             "Be sure to use every 'cg' probe and remove any 'non-cg' probe."))

    # minimum and maximum beta per site ----------------------------------------
    old_warn <- getOption("warn")
    beta_max <- suppressWarnings(apply(tumor, 1, max, na.rm=T))
    beta_min <- suppressWarnings(apply(tumor, 1, min, na.rm=T))
    hyper_idx <- which(beta_min < .40 & beta_max > .90 & auc > .80)
    hypo_idx  <- which(beta_min < .10 & beta_max > .60 & auc < .20)

    message(sprintf("[%s] Total hyper-methylated sites = %i", Sys.time(), length(hyper_idx)))
    message(sprintf("[%s] Total hypo-methylated sites = %i",  Sys.time(), length(hypo_idx)))

    ordered_hyper_idx <- hyper_idx[order(auc[hyper_idx], decreasing=T)]
    ordered_hypo_idx  <- hypo_idx[order(auc[hypo_idx], decreasing=F)]

    message(sprintf("[%s] Hyper-methylated sites cluster reduction...", Sys.time()))
    top_hyper_idx <- cluster_reduction(ordered_hyper_idx, max_sites/2, min_distance, platform_data)
    message(sprintf("[%s] Hypo-methylated sites cluster reduction...", Sys.time()))
    top_hypo_idx <- cluster_reduction(ordered_hypo_idx, max_sites/2, min_distance, platform_data)

    list(hyper=top_hyper_idx, hypo=top_hypo_idx)
}

#' Remove CpG sites too close to each other
#'
#' Remove sites within 'min_distance' (keep only one, per 'cluster'), keeping at most N sites
#' accoring to their order.
#' @param sites_idx a vector of integers
#' @param N number of sites to retrieve
#' @param min_distance an integer (in basepairs)
#' @keywords internal
#' @return a vector of indexes with close sites removed.
cluster_reduction <- function(sites_idx, N, min_distance, platform_data){
    top_idx <- rep(NA, length(sites_idx))
    i <- 1
    n <- 1
    while (n <= N & i <= length(sites_idx)) {
        idx <- sites_idx[i]
        if (!too_close(idx, top_idx[!is.na(top_idx)], min_distance, platform_data)) {
            top_idx[n] <- idx
            n <- n + 1
        }
        i <- i+1
    }
    top_idx <- top_idx[!is.na(top_idx)]
    message(sprintf("[%s] %i sites retrieved after 'cluster reduction'.",
                    Sys.time(), length(top_idx)))
    return(top_idx)
}

#' Check whether a site is too close to the other sites or not
#'
#' Used in "cluster_recution" function only, given the index of a CpG site and
#' a set of indexes of other sites, check if last added site is less than
#' "min_distance" basepair distant from previously retrieved sites.
#' @param new_idx an index (integer)
#' @param prev_idxs a vector of indexes (integer)
#' @param min_distance an integer. Distance in basepairs
#' @keywords internal
#' @return logical
too_close <- function(new_idx, prev_idxs, min_distance, platform_data){
    if (length(prev_idxs) == 0) {
        answer <- FALSE
    } else {
        new_site <- platform_data[new_idx,]
        other_sites <- platform_data[prev_idxs,]
        same_chromosome <- other_sites[["Chromosome"]] == new_site[["Chromosome"]]
        if ("Start" %in% names(platform_data)){
            within_min_distance <- abs(other_sites[["Start"]] - new_site[["Start"]]) < min_distance
        } else {
            within_min_distance <-
                abs(other_sites[["Genomic_Coordinate"]] - new_site[["Genomic_Coordinate"]]) < min_distance
        }
        # pairwise comparision of chromosome location and distance
        answer <- any(same_chromosome & within_min_distance)
    }
    return(ifelse(is.na(answer), F, answer))
}

