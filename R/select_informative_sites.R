#' Select CpG sites required to compute sample purity.
#'
#' Generate a list of sites to be used to compute purity of a set of tumor samples.
#' Informative sites are divided in "hyper" and "hypo" depending on their level of
#' methylation with respect to the average of normal sampels. Both sets will be used.
#'
#' @param tumor A matrix of beta scores generated by an Illumina MethylChip
#' @param control A matrix of beta scores generated by an Illumina MethylChip
#' @param max_NAs_fraction Fraction of NAs above which AUC will not be computed
#' (set to 1 to avoid sites with any NA). Applied independently to each sites (row).
#' @param max_sites Maximum number of sites to retrieve
#' (divided in two sets: "hyper-" and "hypo-methylated")
#' @param min_distance Measured in bp (base pair), used to avoid selection
#' of CpG sites located within this distance from another.
#' @param platform '27k' or '450k' Illumina HumanMethylation BeadChip.
#' @param genome Currently support hg19 or hg38. Used to map probes to genome and
#' remove heavly clusterd probes.
#' @return A list indexes of informative sites (divided into two sets:
#' "hyper-methylated" and "hypo-methylated")
#' @export
#' @examples
#' select_informative_sites(tumor_matrix, control_matrix)
#' select_informative_sites(tumor_matrix, control_matrix, max_sites=40, min_distance=5000)

select_informative_sites <- function(tumor,
                                     control,
                                     max_NAs_fraction=0.5,
                                     max_sites=20,
                                     min_distance=1e6,
                                     platform=c("450k", "27k"),
                                     genome=c("hg19", "hg38")){
    # check parameters ---------------------------------------------------------
    platform <- match.arg(platform)
    genome <- match.arg(genome)
    cat(sprintf("Platform: %s\n", platform))
    cat(sprintf("Genome: %s\n", genome))

    platform_data <- get(paste0("illumina", platform, "_", genome))

    min_distance <- as.integer(min_distance)
    if (min_distance < 0)
       stop("'min_distance' must be positive")
    if (max_sites %% 2 != 0 & !is.integer(max_sites))
        stop ("'max_sites' must be an integer and even number")
    if (max_NAs_fraction < 0 | max_NAs_fraction > 1)
        stop("'max_NAs_fraction' must be positive and lower than or equal to 1")

    tumor   <- as.matrix(tumor)
    control <- as.matrix(control)

    if (any(tumor < 0 | tumor > 1, na.rm=T) | any(control < 0 | control > 1, na.rm=T))
        stop("Beta values in 'tumor' and 'control' matrixes must be decimal.")

    if (nrow(tumor) != nrow(platform_data) | nrow(control) != nrow(platform_data))
        stop(paste0(sprintf("'tumor' and 'control' must have %i number of rows.\n", nrow(platform_data)),
             "Be sure to use every 'cg' probe and remove any 'non-cg' probe."))

    # compute AUC --------------------------------------------------------------
    full_table <- cbind(tumor, control)
    state <- c(rep(1, ncol(tumor)), rep(0, ncol(control)))
    cat(sprintf("[%s] Computing AUC...\n",  Sys.time()))
    auc <- apply(full_table, 1, function(meth_site){
        NAs_tumor   <- (too_many_NAs(meth_site[state==1], max_NAs_fraction))
        NAs_control <- (too_many_NAs(meth_site[state==0], max_NAs_fraction))
        if (NAs_tumor | NAs_control) {
            ans <- NA
        } else {
            non_NA_idx <- which(!is.na(meth_site))
            roc <- ROC::rocdemo.sca(truth=state[non_NA_idx],
                                    data=meth_site[non_NA_idx],
                                    cutpts=seq(0, 1, .01))
            ans <- ROC::AUC(roc)
        }
        return(ans)
    })
    cat(sprintf("[%s] Done.\n",  Sys.time()))

    # compute beta-differences -------------------------------------------------
    tumor_median    <- apply(tumor, 1, median, na.rm=T)
    control_median  <- apply(control, 1, median, na.rm=T)
    beta_difference <- tumor_median - control_median

    # minimum and maximum beta per site ----------------------------------------
    old_warn <- getOption("warn")
    options(warn=-1)
    beta_max <- apply(tumor, 1, max, na.rm=T)
    beta_min <- apply(tumor, 1, min, na.rm=T)
    options(warn=old_warn)
    hyper_idx <- which(beta_min < .40 & beta_max > .90 & auc > .80)
    hypo_idx  <- which(beta_min < .10 & beta_max > .60 & auc < .20)

    cat(sprintf("[%s] Total hyper-methylated sites = %i\n", Sys.time(), length(hyper_idx)))
    cat(sprintf("[%s] Total hypo-methylated sites = %i\n",  Sys.time(), length(hypo_idx)))

    ordered.hyper_idx <- hyper_idx[order(auc[hyper_idx], decreasing=T)]
    ordered.hypo_idx  <- hypo_idx[order(auc[hypo_idx], decreasing=F)]

    cat(sprintf("[%s] Hyper-sites selection: ", Sys.time()))
    top_hyper_idx <- clusters_reduction(ordered.hyper_idx, N=max_sites/2, min_dist=min_distance)

    cat(sprintf("[%s] Hypo-sites selection: ", Sys.time()))
    top_hypo_idx <- clusters_reduction(ordered.hypo_idx, N=max_sites/2, min_dist=min_distance)

    rm(platform_data, envir=.GlobalEnv)
    list(hyper=top_hyper_idx, hypo=top_hypo_idx)
}

#' Check whether vector has too many NA values or not.
#'
#' If set to 1 returns FALSE only if all values are NAs. If set to 0, returns TRUE
#' with a single NA
#' @param x a vector
#' @param threshold maximum fraction of x allowed to be NA
#' @keywords internal
#' @return logical
too_many_NAs <- function(x, threshold){ #
    if (all(is.na(x))){
        ans <- TRUE
    } else {
        NA_table <- table(factor(is.na(x), levels=c(T,F)))
        NA_fraction <- as.numeric(NA_table["TRUE"] / sum(NA_table))
        ans <- NA_fraction > threshold
    }
    return(ans)
}

#' Avoid retrieving of CpG sites too close to each others
#'
#' Remove sites within 'min_dist' (keep only one, per "cluster"), keeping at most N sites
#' @param sites_idx a vector of integers
#' @param N number of sites to retrieve
#' @param min_dist an integer. Distance in basepairs
#' @keywords internal
#' @return a vector of indexes with close sites removed.
clusters_reduction <- function(sites_idx, N, min_dist){
    top_idx <- rep(NA, length(sites_idx))
    i <- 1
    n <- 1
    while (n <= N & i <= length(sites_idx)) {
        idx <- sites_idx[i]
        if (!too_close(idx, top_idx[!is.na(top_idx)], min_dist)) {
            top_idx[n] <- idx
            n <- n + 1
        }
        i <- i+1
    }
    top_idx <- top_idx[!is.na(top_idx)]
    cat(sprintf("%i sites retrieved after 'cluster reduction'.\n", length(top_idx)))
    return(top_idx)
}

#' Check whether a site is too close to the other sites or not.
#'
#' Used in "cluster_recution" function only, given the index of a CpG site and
#' a set of indexes of other sites, check if last added site is less than
#' "d" basepair distant from previously retrieved sites.
#' @param new_idx an index (integer)
#' @param other_idxs a vector of indexes (integer)
#' @param d an integer. Distance in basepairs
#' @keywords internal
#' @return logical
too_close <- function(new_idx, other_idxs, d){
    if (length(other_idxs) == 0) {
        answer <- FALSE
    } else {
        new_site <- platform_data[new_idx,]
        other_sites <- platform_data[other_idxs,]
        same_chromosome <- other_sites[["Chromosome"]] == new_site[["Chromosome"]]
        if ("Start" %in% names(platform_data)){
            within_min_distance <- abs(other_sites[["Start"]] - new_site[["Start"]]) < d
        } else {
            within_min_distance <-
                abs(other_sites[["Genomic_Coordinate"]] - new_site[["Genomic_Coordinate"]]) < d

        }
        # pairwise comparision of chromosome location and distance
        answer <- any(same_chromosome & within_min_distance)
    }
    return(answer)
}
